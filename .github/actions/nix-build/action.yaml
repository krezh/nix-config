---
name: "Nix Build"
description: "Build a Nix flake target with standardized error capture and logging"
author: "krezh"

inputs:
  target:
    description: "Flake target to build (e.g., package-name or top.hostname)"
    required: true
  build-type:
    description: "Type of build (package or system)"
    required: true
  extra-args:
    description: "Extra nix build arguments"
    required: false
    default: ""
  output-link:
    description: "Path for the result symlink (-o flag)"
    required: false
    default: ""

outputs:
  success:
    description: "Whether the build succeeded"
    value: ${{ steps.build.outcome == 'success' }}
  error-log:
    description: "Extracted error log content"
    value: ${{ steps.build.outputs.error-log }}
  build_duration:
    description: "Build duration in seconds"
    value: ${{ steps.build.outputs.build_duration }}

runs:
  using: "composite"
  steps:
    - name: Build ${{ inputs.build-type }}
      id: build
      shell: bash
      run: |
        set -o pipefail
        build_start=$(date +%s)

        # Construct nix build command
        nix_cmd="nix build --fallback --no-write-lock-file --log-format raw \".#${{ inputs.target }}\""

        # Add output link if specified
        if [ -n "${{ inputs.output-link }}" ]; then
          nix_cmd="$nix_cmd -o ${{ inputs.output-link }}"
        fi

        # Add extra args based on build type or custom args
        if [ -n "${{ inputs.extra-args }}" ]; then
          nix_cmd="$nix_cmd ${{ inputs.extra-args }}"
        fi

        # Execute build with error capture
        eval "$nix_cmd" 2>&1 | tee build.log || {
          # Extract derivation paths from build log
          derivation_paths=$(grep -oE '/nix/store/[a-z0-9]+-[^'"'"'[:space:]]+\.drv' build.log | sort -u)

          # Find primary failing derivation - prioritize "Cannot build" over dependencies
          primary_drv=$(grep "^error: Cannot build" build.log | grep -oE '/nix/store/[a-z0-9]+-[^'"'"'[:space:]]+\.drv' | head -1)

          # Fallback to any error line
          if [ -z "$primary_drv" ]; then
            primary_drv=$(grep "^error:" build.log | grep -v "dependencies of" | grep -oE '/nix/store/[a-z0-9]+-[^'"'"'[:space:]]+\.drv' | head -1)
          fi

          # Fallback to first derivation if no primary found
          if [ -z "$primary_drv" ]; then
            primary_drv=$(echo "$derivation_paths" | head -1)
          fi

          # Helper function to retrieve nix log
          get_nix_log() {
            local drv="$1"
            if [ -n "$drv" ]; then
              local log_out=$(nix log "$drv" 2>&1)
              if [ $? -eq 0 ] && [ -n "$log_out" ] && ! echo "$log_out" | grep -q "is not available"; then
                echo "$log_out"
                return 0
              fi
            fi
            return 1
          }

          # Try to retrieve full build log from primary derivation
          full_build_log=""
          if [ -n "$primary_drv" ]; then
            full_build_log=$(get_nix_log "$primary_drv")
          fi

          # If primary failed, try all discovered derivations
          if [ -z "$full_build_log" ] && [ -n "$derivation_paths" ]; then
            while IFS= read -r drv; do
              full_build_log=$(get_nix_log "$drv")
              [ -n "$full_build_log" ] && break
            done <<< "$derivation_paths"
          fi

          # Write multiline output
          {
            echo "error-log<<EOF_ERROR_LOG"

            # Output nix log if available, otherwise use build.log
            if [ -n "$full_build_log" ]; then
              char_count=${#full_build_log}
              if [ $char_count -gt 50000 ]; then
                line_count=$(echo "$full_build_log" | wc -l)
                echo "⚠️ Build log truncated: showing last 2000 of $line_count total lines"
                echo ""
                echo "$full_build_log" | tail -n 2000
              else
                echo "$full_build_log"
              fi
            elif [ -f build.log ] && [ -s build.log ]; then
              # Use build.log as fallback if it exists and is not empty
              cat build.log
            else
              echo "No build log available"
            fi

            echo "EOF_ERROR_LOG"
          } >> "$GITHUB_OUTPUT"

          build_end=$(date +%s)
          build_duration=$((build_end - build_start))
          echo "build_duration=$build_duration" >> "$GITHUB_OUTPUT"

          exit 1
        }

        build_end=$(date +%s)
        build_duration=$((build_end - build_start))
        echo "build_duration=$build_duration" >> $GITHUB_OUTPUT
